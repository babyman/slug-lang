///
/// slug.mustache
/// A native Mustache renderer for Slug.
///
/// Intended to satisfy the official Mustache spec v1.4.3 (core suites).
///

var {*} = import(
	"slug.std",
	"slug.string",
)

val DEFAULT_OTAG = '{{'
val DEFAULT_CTAG = '}}'

// Node shapes:
//  {type:"text", text:"..."}
//  {type:"var", name:"a.b", escape:true/false}
//  {type:"section", name:"items", inverted:false, children:[...], raw:"...", otag:"{{", ctag:"}}"}
//  {type:"partial", name:"p", indent:"   "}

var isWs = fn(@str s) {
	if (s == nil || len(s) == 0) {
		true 
	} else {
		var i = 0
		fn() {
			if (i >= len(s)) {
				true 
			} else {
				var c = s[i]
				if (c == " " || c == "\t" || c == "\r") {
					i = i + 1
					recur()
				} else {
					false
				}
			}
		}()
	}
}

var lineStart = fn(@str s, @num idx) {
	var k = if(idx <= 0) {-1} else {(s[:idx] /> lastIndexOf("\n"))}
	if(k < 0) {0} else {(k + 1)}
}

var lineEnd = fn(@str s, @num idx) {
	var k = s /> indexOf("\n", idx)
	if(k < 0) {len(s)} else {k}
}

var htmlEscape = fn(@str s) {
	if (s == nil) { 
		"" 
	} else {
		s
			/> replaceAll("&", "&amp;")
			/> replaceAll("<", "&lt;")
			/> replaceAll(">", "&gt;")
			/> replaceAll("\"", "&quot;")
			/> replaceAll("'", "&#39;")
	}
}

var isFalsey = fn(v) {
	match v /> type() {
		^NIL_TYPE => true
		^BOOLEAN_TYPE => v == false
		^LIST_TYPE => len(v) == 0
		_ => false
	}
}

var lookupIn = fn(ctx, parts, idx = 0) {
	if (idx >= len(parts)) {
		ctx
	} else {
		var key = parts[idx]
		if (key == ".") {
			recur(ctx, parts, idx + 1)
		} else if (type(ctx) == MAP_TYPE) {
			recur(ctx[key], parts, idx + 1)
		} else {
			nil
		}
	}
}

var lookup = fn(@list stack, @str name, i = nil) {
	if (i == nil) { i = len(stack) - 1 }
	if (i < 0) { 
		nil 
	} else {
		var ctx = stack[i]
		if (name == ".") {
			ctx
		} else {
			var parts = name /> split(".")
			var first = parts[0]
			if (type(ctx) == MAP_TYPE && ctx[first] != nil) {
				lookupIn(ctx, parts)
			} else if (i > 0) {
				recur(stack, name, i - 1)
			} else {
				nil
			}
		}
	}
}

var indentPartial = fn(@str partial, @str indent) {
	if (indent == "" || partial == nil || partial == "") {
		partial /> ifNil("")
	} else {
		var out = ""
		var i = 0
		fn() {
			if (i >= len(partial)) { 
				out 
			} else {
				var c = partial[i]
				out = out + c
				if (c == "\n" && i < len(partial) - 1) {
					out = out + indent
				}
				i = i + 1
				recur()
			}
		}()
	}
}

var resolvePartial = fn(partials, @str name) {
	if (partials == nil) {
		nil
	} else if (type(partials) == MAP_TYPE) {
		partials[name]
	} else if (type(partials) == FUNCTION_TYPE) {
		partials(name)
	} else {
		throw {type:"error", msg:"partials must be a map or a loader function"}
	}
}

@export
var parse = fn(@str template) {
	var otag = DEFAULT_OTAG
	var ctag = DEFAULT_CTAG

	var root = {name:"__root__", inverted:false, nodes:[]}
	var stack = [root]

	var pushNode = fn(stack, node) {
		var top = stack[len(stack) - 1]
		var updated = top /> put("nodes", top.nodes :+ node)
		stack /> update(len(stack) - 1, updated)
	}

	var openSection = fn(stack, name, inverted, contentStart, ot, ct) {
		stack :+ {name:name, inverted:inverted, nodes:[], contentStart:contentStart, otag:ot, ctag:ct}
	}

	var closeSection = fn(stack, name, rawInner) {
		if (len(stack) <= 1) {
			throw {type:"error", msg:'Mustache close tag without open: {{' + name + '}}'}
		}
		var frame = stack[len(stack) - 1]
		if (frame.name != name) {
			throw {type:"error", msg:'Mustache section mismatch: expected {{' + frame.name + '}} got {{' + name + '}}'}
		}
		var parent = stack[:len(stack) - 1]
		var node = {type:"section", name:frame.name, inverted:frame.inverted, children:frame.nodes, raw:rawInner, otag:frame.otag, ctag:frame.ctag}
		parent /> then(fn(ps) { pushNode(ps, node) })
	}

	var eligibleStandalone = fn(sig) {
		sig == "!" || sig == ">" || sig == "#" || sig == "^" || sig == "/" || sig == "="
	}

	var i = 0
	var n = len(template)

	fn() {
		if (i >= n) { nil 
		} else {
			var open = template /> indexOf(otag, i)
			if (open < 0) {
				stack = stack /> then(fn(st) { pushNode(st, {type:"text", text:template[i:]}) })
				i = n
				recur()
			} else {
				// triple mustache is current otag + "{" and "}" + current ctag
				var tripleOpen = otag + "{"
				var tripleClose = "}" + ctag
				var isTriple = template[open:open + len(tripleOpen)] == tripleOpen
				var tagOpenLen = if(isTriple) {len(tripleOpen)} else {len(otag)}
				var closeDelim = if(isTriple) {tripleClose} else {ctag}

				var end = template /> indexOf(closeDelim, open + tagOpenLen)
				if (end < 0) { throw {type:"error", msg:"Unclosed mustache tag"} }

				var tagEnd = end + len(closeDelim)
				var tagRaw = template[open + tagOpenLen:end]
				var tag = tagRaw /> trim()
				var sig = if(len(tag) > 0) {tag[0]} else {""}

				var ls = lineStart(template, open)
				var le = lineEnd(template, tagEnd)
				var before = template[ls:open]
				var after = template[tagEnd:le]
				var standalone = (len(tag) > 0) && eligibleStandalone(sig) && isWs(before) && isWs(after)

				// If this tag is standalone, its line ending is ignored (but not required).
				// This affects where "section content" begins for the purposes of capturing raw
				// section text (used by the spec for lambdas in other implementations).
				var afterStandalone = if(standalone) {
						if(le < len(template) && template[le:le + 1] == "\n") {(le + 1)} else {le}
					} else {
						tagEnd
					}

				// emit text preceding tag; for standalone tags, drop indentation-only prefix on that line
				var textEnd = if(standalone) {ls} else {open}
				if (textEnd > i) {
					stack = stack /> then(fn(st) { pushNode(st, {type:"text", text:template[i:textEnd]}) })
				}

				if (len(tag) > 0) {
					if (isTriple) {
						stack = stack /> then(fn(st) { pushNode(st, {type:"var", name:tag, escape:false}) })
					} else {
						match sig {
							"!" => { }
							"#" => {
								var name = tag[1:] /> trim()
								stack = openSection(stack, name, false, afterStandalone, otag, ctag)
							}
							"^" => {
								var name = tag[1:] /> trim()
								stack = openSection(stack, name, true, afterStandalone, otag, ctag)
							}
							"/" => {
								var name = tag[1:] /> trim()
								var frame = stack[len(stack) - 1]
								var raw = ""
								if (frame.contentStart != nil && frame.contentStart <= open) {
									raw = template[frame.contentStart:open]
								}
								stack = closeSection(stack, name, raw)
							}
							"&" => {
								var name = tag[1:] /> trim()
								stack = stack /> then(fn(st) { pushNode(st, {type:"var", name:name, escape:false}) })
							}
							">" => {
								var name = tag[1:] /> trim()
								var indent = if(standalone) {before} else {""}
								stack = stack /> then(fn(st) { pushNode(st, {type:"partial", name:name, indent:indent}) })
							}
							"=" => {
								// {{=<% %>=}} : must begin and end with '='
								if (tag[len(tag) - 1] != "=") {
									throw {type:"error", msg:"Invalid set delimiter tag"}
								}
								var inner = tag[1:len(tag) - 1] /> trim()
								var parts = inner /> split(" ") /> filter(fn(p) { p != "" })
								if (len(parts) != 2) {
									throw {type:"error", msg:"Invalid set delimiter tag"}
								}
								otag = parts[0]
								ctag = parts[1]
							}
							_ => {
								stack = stack /> then(fn(st) { pushNode(st, {type:"var", name:tag, escape:true}) })
							}
						}
					}
				}

				// advance i; for standalone tags, remove trailing whitespace and optional newline
				if (standalone) {
					if (le < len(template) && template[le:le + 1] == "\n") {
						i = le + 1
					} else {
						i = le
					}
				} else {
					i = tagEnd
				}

				recur()
			}
		}
	}()

	if (len(stack) != 1) {
		var top = stack[len(stack) - 1]
		throw {type:"error", msg:'Unclosed mustache section: {{#' + top.name + '}}'}
	}

	stack[0].nodes
}

var getPartialAst = fn(partials, cache, name) {
	var src = resolvePartial(partials, name)
	if (src == nil) {
		{ast:nil, cache:cache, src:nil}
	} else {
		var e = cache[name]
		if (e != nil && e.src == src) {
			{ast:e.ast, cache:cache, src:src}
		} else {
			var ast = parse(src)
			var cache2 = cache /> put(name, {src:src, ast:ast})
			{ast:ast, cache:cache2, src:src}
		}
	}
}

var renderNodesCached = fn(nodes, ctxStack, partials, cache, acc = "", indent = "") match {
	[[], ...] => { {html:acc, cache:cache} }
	[[node, ...rest], ...] => {
		match node.type {
			"text" => {
				var text = indentPartial(node.text, indent)
				recur(rest, ctxStack, partials, cache, acc + text)
			}

			"var" => {
				var v = lookup(ctxStack, node.name)
				var s = if(v == nil) {""} else {(v /> toString())}
				var out = if(node.escape) {htmlEscape(s)} else {s}
				var indented = indentPartial(out, indent)
				recur(rest, ctxStack, partials, cache, acc + indented)
			}

			"partial" => {
				var r = getPartialAst(partials, cache, node.name)
				if (r.ast == nil) {
					recur(rest, ctxStack, partials, r.cache, acc)
				} else {
					var indent = node.indent /> ifNil("")
					var rendered = renderNodesCached(r.ast, ctxStack, partials, r.cache, "", indent)
					var html = indent + rendered.html
					recur(rest, ctxStack, partials, rendered.cache, acc + html)
				}
			}

			"section" => {
				var v = lookup(ctxStack, node.name)
				if (node.inverted) {
					if (isFalsey(v)) {
						var inner = renderNodesCached(node.children, ctxStack, partials, cache, "")
						recur(rest, ctxStack, partials, inner.cache, acc + inner.html)
					} else {
						recur(rest, ctxStack, partials, cache, acc)
					}
				} else {
					if (isFalsey(v)) {
						recur(rest, ctxStack, partials, cache, acc)
					} else if (type(v) == LIST_TYPE) {
						var each = fn(items, acc2, cache2) match {
							[[], ...] => { {html:acc2, cache:cache2} }
							[[h, ...t], ...] => {
								var inner = renderNodesCached(node.children, ctxStack :+ h, partials, cache2, "")
								each(t, acc2 + inner.html, inner.cache)
							}
						}
						var r2 = each(v, "", cache)
						recur(rest, ctxStack, partials, r2.cache, acc + r2.html)
					} else if (type(v) == MAP_TYPE) {
						var inner = renderNodesCached(node.children, ctxStack :+ v, partials, cache, "")
						recur(rest, ctxStack, partials, inner.cache, acc + inner.html)
					} else {
						var inner = renderNodesCached(node.children, ctxStack :+ v, partials, cache, "")
						recur(rest, ctxStack, partials, inner.cache, acc + inner.html)
					}
				}
			}

			_ => throw {type:"error", msg:"Unknown mustache node type: " + node.type}
		}
	}
}

@export
var renderCached = fn(templateOrAst, data, partials = nil, cache = {}) {
	var ast = if(type(templateOrAst) == STRING_TYPE) {parse(templateOrAst)} else {templateOrAst}
	renderNodesCached(ast, [data], partials, cache, "")
}

@export
var render = fn(templateOrAst, data, partials = nil) {
	renderCached(templateOrAst, data, partials, {}).html
}

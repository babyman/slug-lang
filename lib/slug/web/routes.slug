var {*} = import (
	"slug.io.tcp",
	"slug.std",
	"slug.string",
	"slug.time",
	"slug.channel",
	"slug.io.fs",
	"slug.web.request",
	"slug.web.response",
)

val Route = struct {
	@str method,
	@str pattern,
	@fn handler,
}

val Router = struct {
	@list routes,
}


// ------------------
// Core constructors
// ------------------

@export
var router = fn() {
	Router { routes: [] }
}

// ------------------
// Introspection
// ------------------

@export var isRouter = fn(x) match { Router { routes } => true _ => false }

// ------------------
// Basic modifiers
// ------------------

var addRoute = fn(r, @str method, @str pattern, @fn handler) {
  r copy { routes: r.routes :+ Route { method: method, pattern: pattern, handler: handler } }
}

@export
var head  = fn(r, @str pattern, @fn handler) { addRoute(r, "HEAD",  pattern, handler) }

@export
var get  = fn(r, @str pattern, @fn handler) { addRoute(r, "GET",  pattern, handler) }

@export
var post = fn(r, @str pattern, @fn handler) { addRoute(r, "POST", pattern, handler) }

// mount = any method, prefix
@export
var mount = fn(r, @str prefix, @fn handler) { addRoute(r, "*", prefix + "/*", handler) }

@export
var mountRouter = fn(r, @str prefix, childRouter) { mount(r, prefix, subrouter(childRouter)) }

// ------------------
// Public
// ------------------

@export
var handle = fn(request, r) {
	match handleRequest(r.routes, request) {
		nil => notFound()
		response => response
	}
}

// ------------------
// Internals
// ------------------

var handleRequest = fn(@list routes, request) match {
	[[], ...] => nil
	[[route, ...t], ...] => {
		if (route.method == request.method || route.method == "*") {
			match matchRoutePattern(route.pattern, request.path) {
				nil => recur(t, request)
				params => request /> withParams(params) /> route.handler
			}
		} else {
			recur(t, request)
		}
	}
}

var matchRoutePattern = fn(pattern, path) {
	// prefix mount: "/static/*"
	if (pattern /> endsWith("/*")) {
		var base = pattern[0:-2] // strip "/*"

		if (path == base) {
			{ "*": "" }
		} else if (path /> startsWith(base + "/")) {
			{ "*": path[len(base):] }          // remainder begins with "/..."
		} else {
			nil
		}
	} else {
		// existing exact-segment matcher
		var ps = pattern /> split("/")
		var xs = path    /> split("/")

		if (len(ps) != len(xs)) {
			nil
		} else {
			ps /> zip(xs) /> reduce({}, fn(params, pair) {
				var p = pair[0]
				var x = pair[1]
				if (p == nil) {
					params
				} else if (p /> startsWith(":")) {
					params /> put(p[1:], x)
				} else if (p == x) {
					params
				} else {
					nil
				}
			})
		}
	}
}

// ------------------
// subrouters, allows router nesting
// ------------------

@export
var subrouter = fn(router) {
  fn(req) {
	// remainder captured by mount "/prefix/*"
	var rest = req.params["*"]
	if (rest == nil || rest == "") {
		rest = "/"
	}

	// normalize so inner routes can be defined like "/users/:id"
	if (rest[0:1] != "/") {
		rest = "/" + rest
	}

	req /> withPath(rest)
		// IMPORTANT: clear the "*" param so it doesn't leak into inner router
		// (optional, but usually nicer)
		/> withoutParam("*")
		/> handle(router) 
  }
}


// ------------------
// static file handler
// ------------------

@export
var static = fn(dir, cacheTimeSeconds = 3600) {
	fn(req) {
		defer onerror(err) notFound()
		
		if (req.method != "GET" && req.method != "HEAD") {
			nil
		} else {
			// remainder supplied by mount("/static", ...)
			var rel = req.params["*"]

			// mount captured remainder like "/app.css" (or "")
			if (rel == nil || rel == "" || rel == "/") {
				rel = "/index.html"
			}
			
			if (rel[0:1] == "/") {
				rel = rel[1:]
			}

			if (!isSafeRelPath(rel)) {
				notFound()
			} else {
				var full = joinPath(dir, rel)
				var body = readFile(full)

				match req.method {
					"HEAD" => html("")
					_ => html(body)
				}
					/> withContentType(rel /> ext /> contentType)
					/> cacheSeconds(cacheTimeSeconds)
			}
		}
	}
}

var ext = fn(path) {
	var i = path /> lastIndexOf(".")
	if (i < 0) {
		"" 
	} else {
		path[i:] 
	}
}

var contentType = fn(path) match {
	".css"  => "text/css; charset=utf-8";
	".js"   => "text/javascript; charset=utf-8";
	".html" => "text/html; charset=utf-8";
	".htm"  => "text/html; charset=utf-8";
	".txt"  => "text/plain; charset=utf-8";
	".svg"  => "image/svg+xml";
	".json" => "application/json; charset=utf-8";
	".png"  => "image/png";
	".jpg"  => "image/jpeg";
	".jpeg" => "image/jpeg";
	".gif"  => "image/gif";
	".ico"  => "image/x-icon";
	_       => "application/octet-stream";
}


// prevent .. traversal (v0: simple + effective)
var isSafeRelPath = fn(p) {
	// normalize separators first if you have that; this covers the common case
	!(p /> contains(".."))
}

// join dir + rel path (assumes dir has no trailing slash issues; adjust if needed)
var joinPath = fn(dir, rel) {
	if (dir /> endsWith("/")) { dir + rel } else { dir + "/" + rel }
}


// ------------------
// logging wrapper
// ------------------

@export
var withLog = fn(handler) {
	fn(req) {
		var d = delta(clock)

		var res = handler(req)

		var ts = fmtClock(clock(), "2006-01-02 15:04:05.000")
		var msg = []
		if (req.requestId) { msg = msg :+ req.requestId }
		if (req.traceId) { msg = msg :+ req.traceId }
		if (req.spanId) { msg = msg :+ req.spanId }
		msg = msg :+ req.path
		printf("{s} [ {:<4s} ] {:d}ms {:d} {s}", ts, req.method, d(), res.status, msg /> join(" ")) /> println;
		res
	}
}

// ------------------
// timeout wrapper
// ------------------

@export
var withTimeout = fn(h, ms) {
	fn(req) {
		var task = spawn { h(req) }
		await(task, ms)
	}
}

// ------------------
// simple error handling wrapper
// ------------------

@export
var withRecover = fn(h) {
	fn(req) {
		defer onerror(err) {
			serverError()
		}
		h(req)
	}
}

// ------------------
// add a response header
// ------------------

@export
var withHeader = fn(@fn handler, @str header, @str value) {
	fn(req) {
		req /> handler /> withHeader(header, value)
	}
}

// ------------------
// add a request id for logging
// ------------------

@export
var withRequestId = fn(@fn handler, @fn newRequestId = nil) {
	newRequestId = if (newRequestId) {newRequestId} else {fn() { randomHexString(32) }}
	fn(req) {
		var rid = req.headers["x-request-id"]

		if (rid == nil) {
			rid = newRequestId()
		}

		// attach to request
		req = req copy { requestId: rid }

		var res = handler(req)

		if (res != nil) {
			res /> withHeader("X-Request-Id", rid)
		} else {
			res
		}
	}
}

// ------------------
// add trace and span ids for logging
// ------------------

@export
var withTraceContext = fn(handler, @fn newTraceId = nil, @fn newSpanId = nil) {
	newTraceId = if (newTraceId) {newTraceId} else {fn() { randomHexString(32) }}
	newSpanId = if (newSpanId) {newSpanId} else {fn() { randomHexString(16) }}
	fn(req) {

		var tp = req.headers["traceparent"]

		var traceId = ""
		var parentId = ""

		if (tp != nil) {
			// Parse existing: 00-traceid-spanid-flags
			var parts = tp /> split("-")
			if (len(parts) >= 3) {
				traceId = parts[1]
				parentId = parts[2]
			}
		}

		// If no incoming trace, start a new one
		if (traceId == "") {
			traceId = newTraceId()
		}

		// Generate a new span ID for this specific execution unit
		var currentSpanId = newSpanId()

		// Construct the new traceparent for downstream/response
		// 00 is the version, 01 means "sampled" (recorded)
		var newTraceParent = "00-" + traceId + "-" + currentSpanId + "-01"

		// Attach to request context so internal logic can use it
		var res = req copy { traceId: traceId, spanId: currentSpanId } /> handler

		if (res != nil) {
			res /> withHeader("traceparent", newTraceParent)
		} else{
			res
		}
	}
}


// ------------------
// enforce a maximum request body size
// ------------------

@export
var withMaxBody = fn(h, maxBytes = 1_048_576) {
	fn(req) {
		// only enforce for methods that may have bodies
		if (req.method == "POST" || req.method == "PUT" || req.method == "PATCH") {
			var cl = req.headers["content-length"]

			if (cl != nil) {
				var n = cl /> toNumber
				if (n > maxBytes) {
					return payloadTooLarge()
				}
			}
		}

		h(req)
	}
}

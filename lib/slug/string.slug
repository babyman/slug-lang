var {*} = import (
    "slug.std"
);

@testWith(
	[nil], nil,
	[""], "",
	[" slug "], "slug",
)
@export
foreign trim = fn(@str str);

@testWith(
	["hello slug", "lu"], 7,
	["hello slug", "l"], 2,
	["hello slug", "l", 2 + 1], 3,
	["hello slug", "l", 4], 7,
	["éé|éé", "|"], 2,
)
@export
foreign indexOf = fn(@str str, @str seq, @num index = 0);

@testWith(
	["hello slug", "l"], 7,
	["hello slug", "h"], 0,
	["hello slug", "g"], 9,
)
@export
var lastIndexOf = fn(@str str, @str seq, @num index = 0, prev = -1) {
	var i = indexOf(str, seq, index)
	if ( i == -1) {
		prev
	} else {
		recur(str, seq, i + 1, i);
	}
}

@testWith(
	[nil], nil,
	[""], "",
	["slug"], "SLUG",
)
@export
foreign toUpper = fn(@str str);

@testWith(
	[nil], nil,
	[""], "",
	["SLUG"], "slug",
)
@export
foreign toLower = fn(@str str);

@testWith(
	["hello slug", "slug"], true,
	["hello slug", "snail"], false,
)
@export
var contains = fn(@str str, @str seq) {
	str /> indexOf(seq) >= 0;
}

@testWith(
	["hello slug", "slug"], false,
	["hello slug", "hello"], true,
)
@export
var startsWith = fn(@str str, @str start) {
	str[:len(start)] == start;
}

@testWith(
	["hello slug", "slug"], true,
	["hello slug", "hello"], false,
)
@export
var endsWith = fn(@str str, @str end) {
	str[len(str) - len(end):] == end;
}

@testWith(
	[nil], false,
	[""], false,
	["slug"], false,
	["SLUG"], true,
)
@export
var isUpper = fn(@str str) {
	if (str != nil && len(str) > 0) {
		str == str /> toUpper();
	} else {
		false
	}
}

@testWith(
	[nil], false,
	[""], false,
	["slug"], true,
	["SLUG"], false,
)
@export
var isLower = fn(@str str) {
	if (str != nil && len(str) > 0) {
		str == str /> toLower();
	} else {
		false
	}
}

// split splits a string into a list of substrings based on a delimiter
// Parameters:
//   str: The input string to split
//   delimiter: The delimiter string to split on
//   max: Maximum number of splits to perform (-1 for unlimited)
//   count: Internal counter for number of splits performed
//   strs: Internal accumulator for storing split strings
// Returns:
//   Array of substrings split by the delimiter
@testWith(
	["slug/test", "/"], ["slug", "test"],
	["éé|éé", "|"], ["éé", "éé"],
)
@export
var split = fn(@str str, @str delimiter, @num max = -1, @num count = 1, @list strs = []) {
	match str /> indexOf(delimiter) {
		n if n >= 0 && (max < 0 || count < max) => {
			val i = n + delimiter /> len();
			recur(str[i:], delimiter, max, count + 1, strs :+ str[:n]);
		}
		_ => strs :+ str;
	}
}

@testWith(
	[[], "."], "",
	[["slug"], "."], "slug",
	[["slug", "test"], "."], "slug.test",
)
@export
var join = fn(strs, @str delimiter, @str str = nil) match {
	[[], ...] if str == nil => "";
	[[], ...] => str;
	[[h, ...t], ...] if str == nil => recur(t, delimiter, h);
	[[h, ...t], ...] => recur(t, delimiter, str + delimiter + h);
}

@testWith(
	[nil, "/", "."], nil,
	["slug/test", "/", "."], "slug.test",
	["slug", "/", "."], "slug",
	["E &amp; S", "&amp;", "&"], "E & S",
)
@export
var replaceAll = fn(@str str, @str replace, @str with) match {
	[nil, ...] => nil;
	[...] => str /> split(replace) /> join(with);
}

@export
var padRight = fn(@str str, @str with, @num length) {
	if (length <= len(str)) {
		str
	} else {
		recur(str + with, with, length)
	}
}

@export
var padLeft = fn(@str str, @str with, @num length) {
	if (length <= len(str)) {
		str
	} else {
		recur(with + str, with, length)
	}
}


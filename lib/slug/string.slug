var {*} = import (
    "slug.std"
);

@testWith(
	[nil], nil,
	[""], "",
	[" slug "], "slug"
)
@export
foreign trim = fn(@str str);

@testWith(
	["hello slug", "lu"], 7,
	["hello slug", "l"], 2,
	["hello slug", "l", 2 + 1], 3,
	["hello slug", "l", 4], 7,
	["éé|éé", "|"], 2
)
@export
foreign indexOf = fn(@str str, @str seq, @num index = 0);

@testWith(
	[nil], nil,
	[""], "",
	["slug"], "SLUG"
)
@export
foreign toUpper = fn(@str str);

@testWith(
	[nil], nil,
	[""], "",
	["SLUG"], "slug"
)
@export
foreign toLower = fn(@str str);

@testWith(
	["hello slug", "slug"], true,
	["hello slug", "snail"], false
)
@export
var contains = fn(@str str, @str seq) {
	str /> indexOf(seq) >= 0;
}

@testWith(
	["hello slug", "slug"], false,
	["hello slug", "hello"], true
)
@export
var startsWith = fn(@str str, @str start) {
	str[:len(start)] == start;
}

@testWith(
	["hello slug", "slug"], true,
	["hello slug", "hello"], false
)
@export
var endsWith = fn(@str str, @str end) {
	str[len(str) - len(end):] == end;
}

@testWith(
	[nil], false,
	[""], false,
	["slug"], false,
	["SLUG"], true
)
@export
var isUpper = fn(@str str) {
	if (str != nil && len(str) > 0) {
		str == str /> toUpper();
	} else {
		false
	}
}

@testWith(
	[nil], false,
	[""], false,
	["slug"], true,
	["SLUG"], false
)
@export
var isLower = fn(@str str) {
	if (str != nil && len(str) > 0) {
		str == str /> toLower();
	} else {
		false
	}
}

// split splits a string into a list of substrings based on a delimiter
// Parameters:
//   str: The input string to split
//   delimiter: The delimiter string to split on
//   max: Maximum number of splits to perform (-1 for unlimited)
//   count: Internal counter for number of splits performed
//   strs: Internal accumulator for storing split strings
// Returns:
//   Array of substrings split by the delimiter
@testWith(
	["slug/test", "/"], ["slug", "test"],
	["éé|éé", "|"], ["éé", "éé"]
)
@export
var split = fn(@str str, @str delimiter, @num max = -1, @num count = 1, @list strs = []) {
	match str /> indexOf(delimiter) {
		n if n >= 0 && (max < 0 || count < max) => {
			val i = n + delimiter /> len();
			split(str[i:], delimiter, max, count + 1, strs :+ str[:n]);
		}
		_ => strs :+ str;
	}
}

@testWith(
	[[], "."], "",
	[["slug"], "."], "slug",
	[["slug", "test"], "."], "slug.test"
)
@export
var join = fn(strs, @str delimiter, @str str = nil) {
	match strs {
		[] if str == nil => "";
		[] => str;
		[h, ...t] if str == nil => join(t, delimiter, h);
		[h, ...t] => join(t, delimiter, str + delimiter + h);
	}
}

@testWith(
	[nil, "/", "."], nil,
	["slug/test", "/", "."], "slug.test",
	["slug", "/", "."], "slug",
	["E &amp; S", "&amp;", "&"], "E & S"
)
@export
var replaceAll = fn(@str str, @str replace, @str with) {
	if (str == nil) {
		nil
	} else {
		str /> split(replace) /> join(with);
	}
}

@export
var padRight = fn(@str str, @str with, @num length) {
	if (length <= len(str)) {
		str
	} else {
		padRight(str + with, with, length)
	}
}

@export
var padLeft = fn(@str str, @str with, @num length) {
	if (length <= len(str)) {
		str
	} else {
		padLeft(with + str, with, length)
	}
}


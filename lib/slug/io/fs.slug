var {*} = import(
    "slug.actor",
    "slug.bytes",
    "slug.std",
);

@export val READ_MODE = "r";
@export val WRITE_MODE = "w";
@export val APPEND_MODE = "a";

@export
var readFileBytes = fn(@str path) {
	sendFsSync({type: "readFile", path: path})
}

// readFile reads entire file content as a string
// Parameters:
//   path: path to the file to read
// Returns:
//   string content of file, or error if file cannot be read
// @export
// foreign readFile = fn(@str path);
@export
var readFile = fn(@str path) {
	readFileBytes(path) /> bytesToStr
}

// writeFile writes string content to a file
// Parameters:
//   contents: string data to write
//   path: path to file to write
// Returns:
//   the number of bytes written on success, error if write fails
@export
var writeFile = fn(@str contents, @str path) {
	sendFsSync({type: "writeFile", path: path, data: contents})
}

@export
var writeFile = fn(@bytes contents, @str path) {
	sendFsSync({type: "writeFile", path: path, data: contents})
}

// appendFile appends string content to end of file
// Parameters:
//   contents: string data to append
//   path: path to file to append to
// Returns:
//   the number of bytes written on success, error if write fails
@export
var appendFile = fn(@str contents, @str path) {
	sendFsSync({type: "writeFile", mode: APPEND_MODE, path: path, data: contents})
}

@export
var appendFile = fn(@bytes contents, @str path) {
	sendFsSync({type: "writeFile", mode: APPEND_MODE, path: path, data: contents})
}

// info gets information about a file
// Parameters:
//   path: path to file to get info for
// Returns:
//   object containing file metadata
@export
var info = fn(@str path) {
	sendFsSync({type: "info", path: path})
}

// exists checks if a file exists and is accessible
// Parameters:
//   path: path to check
// Returns:
//   true if file exists and is accessible, false otherwise
@export
var exists = fn(@str path) {
	sendFsSync({type: "exists", path: path})
}

@export
var mkDirs = fn(@str path) {
	sendFsSync({type: "mkdirs", path: path})
}

// isDir checks if path points to a directory
// Parameters:
//   path: path to check
// Returns:
//   true if path is a directory, false otherwise
@export
var isDir = fn(@str path) {
	info(path).isDir
}

// ls lists contents of a directory (non-recursively)
// Parameters:
//   path: directory path to list
// Returns:
//   list of filenames in the directory
@export
var ls = fn(@str path) {
	sendFsSync({type: "ls", path: path})
}

// rm removes a file or empty directory
// Parameters:
//   path: path to remove
// Returns:
//   nil on success, error if removal fails
@export
var rm = fn(@str path) {
	sendFsSync({type: "rm", path: path})
}

// openFile opens a file in specified mode
// Parameters:
//   path: path to file to open
//   mode: "r" for read, "w" for write, "a" for append
// Returns:
//   file handle number on success, error if open fails
@export
var openFile = fn(@str path, @num replyTo, @str mode) {
	lookup("filesystem") /> send({type:"open", path: path, mode: mode}, replyTo)
	replyTo /> receiveFrom(1000)
}

// readLine reads the next line from an open file
// Parameters:
//   handle: file handle from openFile
// Returns:
//   string containing next line, or error if read fails
@export
var readLine = fn(@num handle, @num replyTo) {
	handle /> send({type: "readLine"}, replyTo)
	replyTo
}


// read reads a fixed number of bytes from file
// Parameters:
//   handle: file handle from openFile
//   count: number of bytes to read
// Returns:
//   bytes containing read bytes, or error if read fails
@export
var read = fn(@num handle, @num replyTo, @num max = 4096) {
	handle /> send({type: "read", max: max}, replyTo)
	replyTo
}

// write writes string content to an open file
// Parameters:
//   handle: file handle from openFile
//   content: string data to write
// Returns:
//   number of bytes written, or error if write fails
@export
var write = fn(@num handle, @num replyTo, @str content) {
	handle /> send({type: "write", data: content}, replyTo)
	replyTo
}

@export
var write = fn(@num handle, @num replyTo, @bytes content) {
	handle /> send({type: "write", data: content}, replyTo)
	replyTo
}

// closeFile closes an open file handle
// Parameters:
//   handle: file handle to close
// Returns:
//   nil on success, error if close fails
@export
var closeFile = fn(@num handle, @num replyTo) {
	handle /> send({type:"close"}, replyTo)
	replyTo /> receiveFrom(1000)
}

@export
var readLines = fn(@num file, @num replyTo, lines = []) {
	match file /> readLine(replyTo) /> receiveFrom(1000) {
		{type: "eof"} => lines
		{type: "readLine", line} => recur(file, replyTo, lines :+ line[:-1]) // -1 to trim the newline
	}
}

@export
var listFilesRecursive = fn(@list path, @fun filter = fn(s) {true}, acc = []) match {
	[[], ...] => acc;
	[[h, ...t], ...] if h /> isDir => {
			var files = ls(h) /> map(fn(v) {h + "/" + v})
			recur(t + files, filter, acc)
		}
	[[h, ...t], ...] if h /> filter => recur(t, filter, acc :+ h);
	[[h, ...t], ...] => recur(t, filter, acc);
}



var sendFsSync = fn(message) {
	var replyTo = spawn()
	defer replyTo /> terminate

	lookup("filesystem") /> send(message, replyTo)
	
	match replyTo /> receiveFrom(1000) {
		map if map.type == "info" => map;
		{type:"readFile", bytes} => bytes;
		{type:"readFile", text} => text;
		{type:"exists", exists} => exists;
		{type:"writeFile", written} => written;
		{type:"ls", entries} => entries;
		{type:"eof"} => nil;
		{type:"mkdirs"} => true;
		{type:"rm"} => true;
		{type:"error", msg} => throw msg;
		_ => throw "timeout";
	}
}
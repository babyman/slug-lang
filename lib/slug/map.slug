var {*} = import(
	"slug.std"
)

@testWith(
	[{a: 1, b: 2}, {b: 3, c: 4}], {a: 1, b: 3, c: 4},
	[{a: 1}, {}], {a: 1},
	[{}, {a: 1}], {a: 1}
)
@export
var merge = fn(@map base, @map patch) {
	patch /> keys() /> reduce(base, fn(acc, k) {
		acc /> put(k, patch[k])
	})
}

@testWith(
	[{a: {x: 1}}, {a: {y: 2}}], {a: {x: 1, y: 2}},
	[{a: 1}, {a: {b: 2}}], {a: {b: 2}},
	[{a: {b: 2}}, {a: 1}], {a: 1}
)
@export
var patch = fn(@map base, @map patchData) {
	patchData /> keys() /> reduce(base, fn(acc, k) {
		var v1 = acc[k]
		var v2 = patchData[k]

		if (type(v1) == MAP_TYPE && type(v2) == MAP_TYPE) {
			acc /> put(k, patch(v1, v2))
		} else {
			acc /> put(k, v2)
		}
	})
}

@testWith(
	[{k1:1}, {k2:2}], {k1:1, k2:2},
	[{k1:1}, {}], {k1:1},
	[{}, {k2:2}], {k2:2},
	[{k1:1}, {k1:9}], {k1:1} // s1 keys are kept on duplicates
)
@export
var union = fn(@map s1, @map s2) {
	s1 /> keys() /> reduce(s2, fn(s, k) {
		s /> put(k, s1[k])
	})
}

@testWith(
	[{k1:1}, {k1:2}], {k1:1},
	[{k1:1}, {k2:2}], {},
	[{}, {k2:2}], {},
	[{k1:1}, {}], {}
)
@export
var intersect = fn(@map s1, @map s2) {
	s1 /> keys()
		/> filter(fn(k) { s2[k] == nil })
		/> reduce(s1, fn(s, k) { s /> remove(k) })
}

@testWith(
	[{k1:1}, {k1:2}], {},
	[{k1:1, k2:1}, {k2:2}], {k1:1}
)
@export
var difference = fn(@map s1, @map s2) {
	s2 /> keys()
		/> reduce(s1, fn(s, k) { s /> remove(k) })
}


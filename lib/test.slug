// Slug Test Framework
//
// This is a simple test framework for Slug programs that allows you to write and run
// unit tests. The framework supports both simple test cases and parameterized tests
// with multiple inputs and expected outputs.
//
// Usage:
//   1. Tag your test functions with either @test or @testWith
//   2. Run your tests using the test runner
//   3. View results including passes, failures and errors
//
// Example:
//   @test
//   var simpleTest = fn() {
//     assert(1 + 1 == 2);
//   }
//
//   @testWith(
//     [1, 2, 3], 3,
//     [7, 9, 8], 9,
//     [4, 5, 3], 5
//   )
//   var max = fn(a, ...b)

var {*} = import(
	"slug.std",
	"slug.map",
	"slug.list",
	"slug.meta",
	"slug.string",
	"slug.time",
	"slug.sys"
);

// @test - Marks a function as a test case that takes no parameters
// @testWith - Allows test inputs and expected outputs to be specified
//
var TEST_WITH_TAG = "@testWith";
var TEST_TAG = "@test";
var timer = delta(clock);

var runTestFn = fn(f, name, stats) {
	try {
		f();
		println("  [\033[32mPASS\033[0m] {{name}}()");
	} catch err {
		{type:"AssertionError", msg} => {
			stats = stats.compute("fail", fn(k, v) { v + 1});
			println("  [\033[31mFAIL\033[0m] {{name}}(): {{msg}}")
		}
		{type} => {
			stats = stats.compute("error", fn(k, v) { v + 1});
			println("  [\033[31mERROR\033[0m] {{name}}() threw {{type}}")
		}
	}
	stats.compute("run", fn(k, v) { v + 1});
}

var runTests = fn(f, name, args, stats) {
	match args {
		[] => stats;
		[a, e, ...t] => {
			try {
				val out = f(...a);
				match out.type() {
					t if t == LIST_TYPE && out.equals(e) => println("  [\033[32mPASS\033[0m] {{name}}({{a}}) == {{out}}");
					t if t == MAP_TYPE && out.equals(e) => println("  [\033[32mPASS\033[0m] {{name}}({{a}}) == {{out}}");
					_ if out == e => println("  [\033[32mPASS\033[0m] {{name}}({{a}}) == {{out}}");
					_ => {
						stats = stats.compute("fail", fn(k, v) { v + 1});
						println("  [\033[31mFAIL\033[0m] {{name}}({{a}}) == {{out}} expected {{e}}");
					}
				}
			} catch err {
				{type} => {
					stats = stats.compute("error", fn(k, v) { v + 1});
					println("  [\033[31mERROR\033[0m] {{name}}({{a}}) == threw {{type}} expected {{e}}")
				}
			}
			stats = stats.compute("run", fn(k, v) { v + 1});
			runTests(f, name, t, stats);
		}
	}
}

var testRunner = fn(module, stats) {
	if(module.endsWith(".slug")) {
		module = module[:-len(".slug")]
	}
	module = module.replaceAll("/", ".")
	println(module + ":")
	var m = module.searchModuleTags(TEST_WITH_TAG, true)
				.union(module.searchModuleTags(TEST_TAG, true))
	m.keys().map(fn(k) {
		var args = m[k].getTag(TEST_WITH_TAG);
		if(args) {
			runTests(m[k], k, args, {run:0, fail:0, error:0});
		} else {
			runTestFn(m[k], k, {run:0, fail:0, error:0});
		}
	}).reduce(stats, fn(vs, new) {
		vs.compute("run", fn(k, v) {v + new[k]})
			.compute("fail", fn(k, v) {v + new[k]})
			.compute("error", fn(k, v) {v + new[k]});
	});
}

var renderResult = fn(stats) {
"""

Results:

Tests run: {{stats.run}}, Failures: {{stats.fail}}, Errors: {{stats.error}}

Total time {{timer()}}ms

"""
}

var run = fn(stats, ...modules) {
	match modules {
		[] => {
			renderResult(stats).println();
			if (stats.fail > 0 || stats.error > 0) {
				exit(1);
			} else {
				exit(0);
			}
		}
		[h, ...t] => run(testRunner(h, stats), ...t);
		_ => "Unrecognized modules parameter!"
	}
}

run({run:0, fail:0, error:0}, ...args);



// Slug Test Framework
//
// This is a simple test framework for Slug programs that allows you to write and run
// unit tests. The framework supports both simple test cases and parameterized tests
// with multiple inputs and expected outputs.
//
// Usage:
//   1. Tag your functions with either @test or @testWith
//   2. Run your tests using the test runner
//   3. View results including passes, failures and errors
//
// Example:
//   @test
//   var simpleTest = fn() {
//     assert(1 + 1 == 2);
//   }
//
//   @testWith(
//     [1, 2, 3], 3,
//     [7, 9, 8], 9,
//     [4, 5, 3], 5
//   )
//   var max = fn(a, ...b)

var {*} = import(
	"slug.std",
	"slug.map",
	"slug.list",
	"slug.meta",
	"slug.string",
	"slug.time",
	"slug.sys"
);

// @test - Marks a function as a test case that takes no parameters
// @testWith - Allows test inputs and expected outputs to be specified
//
val TEST_WITH_TAG = "@testWith";
val TEST_TAG = "@test";

val FAIL = "\033[31;1m";
val PASS = "\033[32m";
val RESET = "\033[0m";

var timer = delta(clock);

var runTestFn = fn(f, name, stats) {
	try {
		f();
		println("  [{{PASS}}PASS{{RESET}}] {{name}}()");
	} catch err {
		{type:"AssertionError", msg} => {
			stats = stats /> compute("fail", fn(k, v) { v + 1});
			println("  [{{FAIL}}FAIL{{RESET}}] {{name}}(): {{msg}}")
		}
		{type} => {
			stats = stats /> compute("error", fn(k, v) { v + 1});
			println("  [{{FAIL}}ERROR{{RESET}}] {{name}}() threw {{type}}")
		}
	}
	stats /> compute("run", fn(k, v) { v + 1});
}

var runTests = fn(f, name, args, stats) {
	match args {
		[] => stats;
		[params, expected, ...t] => {
			try {
				val out = f(...params);
				match out /> type() {
					t if t == LIST_TYPE && out /> equals(expected) => println("  [{{PASS}}PASS{{RESET}}] {{name}}({{params}}) == {{out}}");
					t if t == MAP_TYPE && out /> equals(expected) => println("  [{{PASS}}PASS{{RESET}}] {{name}}({{params}}) == {{out}}");
					_ if out == expected => println("  [{{PASS}}PASS{{RESET}}] {{name}}({{params}}) == {{out}}");
					_ => {
						stats = stats /> compute("fail", fn(k, v) { v + 1});
						println("  [{{FAIL}}FAIL{{RESET}}] {{name}}({{params}}) == {{out}} expected {{expected}}");
					}
				}
			} catch err {
				{type} => {
					stats = stats /> compute("error", fn(k, v) { v + 1});
					println("  [{{FAIL}}ERROR{{RESET}}] {{name}}({{params}}) == threw {{type}} expected {{expected}}")
				}
			}
			stats = stats /> compute("run", fn(k, v) { v + 1});
			runTests(f, name, t, stats);
		}
	}
}

var testRunner = fn(module, stats) {
	if(module /> endsWith(".slug")) {
		module = module[:-len(".slug")]
	}
	module = module /> replaceAll("/", ".")
	println(module + ":")
	var m = module /> searchModuleTags(TEST_WITH_TAG, true)
				/> union(module /> searchModuleTags(TEST_TAG, true))
	m /> keys() /> map(fn(k) {
		var args = m[k] /> getTag(TEST_WITH_TAG);
		if(args) {
			runTests(m[k], k, args, {run:0, fail:0, error:0});
		} else {
			runTestFn(m[k], k, {run:0, fail:0, error:0});
		}
	}) /> reduce(stats, fn(vs, new) {
		vs /> compute("run", fn(k, v) {v + new[k]})
			/> compute("fail", fn(k, v) {v + new[k]})
			/> compute("error", fn(k, v) {v + new[k]});
	});
}

var renderResult = fn(stats) {
	if ( stats.fail > 0 || stats.error > 0 ) {
"""
{{FAIL}}
*******************************************************************************
** 
** Results:
** 
** Tests run: {{stats.run}}, Failures: {{stats.fail}}, Errors: {{stats.error}}
** 
** Total time {{timer()}}ms
** 
*******************************************************************************
{{RESET}}
"""

		} else {
"""

Results:

Tests run: {{stats.run}}, Failures: {{stats.fail}}, Errors: {{stats.error}}

Total time {{timer()}}ms

"""
		}
}

var run = fn(stats, ...modules) {
	match modules {
		[] => {
			renderResult(stats) /> println();
			if (stats.fail > 0 || stats.error > 0) {
				exit(1);
			} else {
				exit(0);
			}
		}
		[h, ...t] => run(testRunner(h, stats), ...t);
		_ => "Unrecognized modules parameter!"
	}
}

run({run:0, fail:0, error:0}, ...args);



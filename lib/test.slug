// Slug Test Framework
//
// This is a simple test framework for Slug programs that allows you to write and run
// unit tests. The framework supports both simple test cases and parameterized tests
// with multiple inputs and expected outputs.
//
// Usage:
//   1. Tag your functions with either @test or @testWith
//   2. Run your tests using the test runner
//   3. View results including passes, failures and errors
//
// Example:
//   @test
//   var simpleTest = fn() {
//     assert(1 + 1 == 2)
//   }
//
//   @testWith(
//     [1, 2, 3], 3,
//     [7, 9, 8], 9,
//     [4, 5, 3], 5
//   )
//   var max = fn(a, ...b)

var {*} = import(
	"slug.std",
	"slug.map",
	"slug.list",
	"slug.meta",
	"slug.string",
	"slug.time",
	"slug.sys",
	"slug.term.colour",
)

// @test - Marks a function as a test case that takes no parameters
// @testWith - Allows test inputs and expected outputs to be specified
//
val TestWithTag = "@testWith"
val TestTag = "@test"

val Fail = BrightColour.Red
val Pass = Colour.Green
val Reset = reset

var timer = delta(clock)


var passed = fn(@str msg) {
	// todo make this a "verbose" commandline parameter
	// println("  [{{Pass}}PASS{{Reset}}] {{msg}}")
}

var runTestFn = fn(f, name, stats) {
	defer onerror(err) {
		match err {
			{type:"AssertionError", msg} => {
				println("  [{{Fail}}FAIL{{Reset}}] {{name}}(): {{msg}}")
				stats /> compute("fail", fn(k, v) { v + 1})
			}
			{type} => {
				println("  [{{Fail}}ERROR{{Reset}}] {{name}}() threw {{type}}")
				stats /> compute("error", fn(k, v) { v + 1})
			}
			_ => {
				println("  [{{Fail}}ERROR{{Reset}}] {{name}}() threw UNKNOWN error type '{{err}}'")
				stats /> compute("error", fn(k, v) { v + 1})
			}
		} /> compute("run", fn(k, v) { v + 1})
	}

	f()
	passed("{{name}}()")
	stats /> compute("run", fn(k, v) { v + 1})
}

var runTest = fn(f, name, params, expected, stats) {
	defer onerror(err) {
		println("  [{{Fail}}ERROR{{Reset}}] {{name}}({{params}}) == threw '{{err}}' expected '{{expected}}'")
		stats /> compute("error", fn(k, v) { v + 1}) /> compute("run", fn(k, v) { v + 1})
	}

	val out = f(...params)

	match out /> type() {
		^LIST_TYPE if out /> equals(expected) => passed("{{name}}({{params}}) == {{out}}")
		^MAP_TYPE if out /> equals(expected)  => passed("{{name}}({{params}}) == {{out}}")
		_ if out == expected => passed("{{name}}({{params}}) == {{out}}")
		_ => {
			stats = stats /> compute("fail", fn(k, v) { v + 1})
			println("  [{{Fail}}FAIL{{Reset}}] {{name}}({{params}}) == '{{out}}' expected '{{expected}}'")
		}
	}
	stats /> compute("run", fn(k, v) { v + 1})
}

var runTests = fn(f, name, args, stats) {
	match args {
		[] => stats
		[params, expected, ...t] => {
			recur(f, name, t, runTest(f, name, params, expected, stats))
		}
	}
}

var testRunner = fn(module, stats) {
	if(module /> endsWith(".slug")) {
		module = module[:-len(".slug")]
	}
	module = module /> replaceAll("/", ".")
	println(module + ":")
	var m = module /> searchModuleTags(TestWithTag, true)
				/> union(module /> searchModuleTags(TestTag, true))
	m /> keys /> sort /> map(fn(k) {
		var args = m[k] /> getTag(TestWithTag)
		if(args) {
			runTests(m[k], k, args, {run:0, fail:0, error:0})
		} else {
			runTestFn(m[k], k, {run:0, fail:0, error:0})
		}
	}) /> reduce(stats, fn(vs, new) {
		vs /> compute("run", fn(k, v) {v + new[k]})
			/> compute("fail", fn(k, v) {v + new[k]})
			/> compute("error", fn(k, v) {v + new[k]})
	})
}

var renderResult = fn(stats) {
	if ( stats.fail > 0 || stats.error > 0 ) {
"""
{{Fail}}
*******************************************************************************
** 
** Results:
** 
** Tests run: {{stats.run}}, Failures: {{stats.fail}}, Errors: {{stats.error}}
** 
** Total time {{timer()}}ms
** 
*******************************************************************************
{{Reset}}
"""

		} else {
"""
{{Pass}}
Results:

Tests run: {{stats.run}}, Failures: {{stats.fail}}, Errors: {{stats.error}}

Total time {{timer()}}ms
{{Reset}}
"""
		}
}

var run = fn(stats, ...modules) match {
	[_, [], ...] => {
			renderResult(stats) /> println()
			if (stats.fail > 0 || stats.error > 0) {
				exit(1)
			} else {
				exit(0)
			}
		}
	[_, [h, ...t], ...] => run(testRunner(h, stats), ...t)
	_ => "Unrecognized modules parameter!"
}

match isDefined("args") {
	true =>	run({run:0, fail:0, error:0}, ...args)
	_    => "This is a command line tool, run with 'slug test ...'"
}



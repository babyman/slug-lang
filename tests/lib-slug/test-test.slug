var {*} = import(
    "slug.std",
    "slug.test",
);

//
// assert something is true
// -----------------------
assert(true);
assert(true, "with a message");

assert(1 == 1);
assert(1 == 1, "with a message");

true /> assertTrue();

true /> ok;

false /> assertFalse();


//
// assert 2 values are equal
// -----------------------
assertEqual(1, 1);
assertEqual(1, 1, "with a message");


var assertTest = fn() {
    defer onerror(err) {
        if( err.type == "AssertionError" ) {
            nil // expect assertion error, not "AnError"
        } else {
            err
        }
    }
    assert(false);
    throw {type: "AnError"};
}

var assertEqualTest = fn() {
    defer onerror(err) {
        if( err.type == "AssertionError" ) {
            nil // expect assertion error, not "AnError"
        } else {
            err
        }
    }
    assertEqual(1, 2);
    throw {type: "AnError"};
}

assertTest()
assertEqualTest()

var confirmAssertFail = fn(f) {
    runSafe(f)
        /> fn(err) {err.error}
        /> isAssertError()
        /> ok
}

//
// test nil / not null assertions
//
nil /> assertNil

confirmAssertFail(fn() { 1 /> assertNil })

1 /> assertNotNil

confirmAssertFail(fn() { nil /> assertNotNil })


//
// test runSafe
//
runSafe(fn(){ 1 }) /> assertEqual({ok:1})

runSafe(fn(){ throw 1 }) /> fn(err) {err.error} /> assertEqual(1)

//
// test assert throws
//
assertThrows(fn(){ throw 1 }, 1) /> ok

// use runSafe to trap the assertion error when assertThrows fails because no error is triggered
confirmAssertFail(fn() { assertThrows(fn() { 1 }, 1)} )

confirmAssertFail(fn() { assertThrows(fn() { throw 1 }, 2)} )


//
// test assert throws type
//
assertErrorType(fn(){ throw 1 }, NUMBER_TYPE) /> ok

confirmAssertFail(fn() { assertErrorType(fn() { 1 }, NUMBER_TYPE)} )

confirmAssertFail(fn() { assertErrorType(fn() { throw 1 }, STRING_TYPE)} )


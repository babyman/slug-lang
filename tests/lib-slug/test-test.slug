var {*} = import(
    "slug.std",
    "slug.test",
);

//
// assert something is true
// -----------------------
assert(true);
assert(true, "with a message");

assert(1 == 1);
assert(1 == 1, "with a message");

true /> assertTrue();

false /> assertFalse();


//
// assert 2 values are equal
// -----------------------
assertEqual(1, 1);
assertEqual(1, 1, "with a message");


var assertTest = fn() {
    defer onerror(err) {
        if( err.type == "AssertionError" ) {
            nil // expect assertion error, not "AnError"
        } else {
            err
        }
    }
    assert(false);
    throw {type: "AnError"};
}

var assertEqualTest = fn() {
    defer onerror(err) {
        if( err.type == "AssertionError" ) {
            nil // expect assertion error, not "AnError"
        } else {
            err
        }
    }
    assertEqual(1, 2);
    throw {type: "AnError"};
}

assertTest()
assertEqualTest()

//
// test runSafe
//
runSafe(fn(){ 1 }) /> assertEqual({ok:1})

runSafe(fn(){ throw 1 }) /> fn(err) {err.error} /> assertEqual(1)

//
// test assert throws
//
assertThrows(fn(){ throw 1 }, 1) /> assertTrue

// use runSafe to trap the assertion error when assertThrows fails because no error is triggered
runSafe(fn() { assertThrows(fn() { 1 }, 1)} )
    /> fn(err) {err.error.type}
    /> assertEqual("AssertionError")

runSafe(fn() { assertThrows(fn() { throw 1 }, 2)} )
    /> fn(err) {err.error.type}
    /> assertEqual("AssertionError")


assertErrorType(fn(){ throw 1 }, NUMBER_TYPE) /> assertTrue

runSafe(fn() { assertErrorType(fn() { 1 }, NUMBER_TYPE)} )
    /> fn(err) {err.error.type}
    /> assertEqual("AssertionError")

runSafe(fn() { assertErrorType(fn() { throw 1 }, STRING_TYPE)} )
    /> fn(err) {err.error.type}
    /> assertEqual("AssertionError")


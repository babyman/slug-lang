/// slug_defer_test_suite.slug
/// -----------------------------------------------------------------------------
/// Slug: Complete Defer / onerror / onsuccess Test Suite (standalone)
///
/// This single file contains:
/// - small test harness (assertEqual + runSafe)
/// - 20 tests covering the defer matrix:
///     1..3 Basic ordering / LIFO
///     4..7 onsuccess/onerror behavior
///     8..11 deferred return transformation & chaining
///     12..16 nested scopes, throws, rethrow, swallow
///     17..20 TCO-related and edge cases
///
/// Each test is commented with its intent. The runner prints PASS / FAIL and
/// a summary at the end.
/// -----------------------------------------------------------------------------

var {*} = import(
    "slug.string",
    "slug.std",
    "slug.test",
)

# ---------- Tests ----------
# 1. Basic defer executes on normal exit
@test
var test1 = fn() {
    var x = []
    var f = fn() {
        defer x = x :+ "A"
        x = x :+ "B"
    }
    f()
    assertEqual(x, ["B","A"], "Test 1 - basic defer on success")
}

# 2. Defers run in LIFO order
@test
var test2 = fn() {
    var x = []
    var f = fn() {
        defer x = x :+ 1
        defer x = x :+ 2
        defer x = x :+ 3
    }
    f()
    assertEqual(x, [3,2,1], "Test 2 - LIFO ordering")
}

# 3. onsuccess runs only on success
@test
var test3 = fn() {
    var x = []
    var f = fn() {
        defer onsuccess     x = x :+ "S"
        defer onerror(err) {x = x :+ "E"; err}
        defer               x = x :+ "A"
        x = x :+ "run"
    }
    f()
    assertEqual(x, ["run","A","S"], "Test 3 - onsuccess only on success")
}

# 4. onerror runs only on error
@test
var test4 = fn() {
    var x = []
    var f = fn() {
        defer onsuccess     x = x :+ "S"
        defer onerror(err) {x = x :+ "E"; throw err}
        defer               x = x :+ "A"
        throw "nope"
    }
    var r = runSafe(fn() { f() })
    # r should be an error map
    assertEqual(r.error, "nope", "Test 4 - thrown value propagated")
    # defers that run: always then onerror (LIFO => A then E)
    assertEqual(x, ["A","E"], "Test 4 - onerror executed on throw")
}

# 7. onerror can convert an error into a normal value (swallow)
@test
var test7 = fn() {
    var f = fn() {
        defer onerror(e) { 42 }   # convert error to normal result
        throw "bad"
    }
    var r = f()
    assertEqual(r, 42, "Test 7 - onerror swallows error and returns value")
}

# 8. onerror rethrows same error (propagate)
@test
var test8 = fn() {
    var f = fn() {
        defer onerror(e) { throw e }  # explicit rethrow
        throw "bad"
    }
    var r = runSafe(f)
    assertEqual(r.error, "bad", "Test 8 - rethrow original error")
}

# 9. onerror throws a new error (wrapping) -> chaining
@test
var test9 = fn() {
    var f = fn() {
        defer onerror(e) { throw "wrapped" }
        throw "inner"
    }
    var r = runSafe(fn() { f() })
    # top-level error must be "wrapped", underlying cause trace must include "inner"
    assertEqual(r.error, "wrapped", "Test 9 - throw new error becomes top-level")
    # The trace is implementation-specific in shape; we assert that a chain exists.
    # If stacktrace returns a list of frames, we at least confirm trace is present.
    assertEqual(r.trace /> contains("Caused by"), true, "Test 9 - trace exists")
}

# 10. inner scope runs its defers first
@test
var test10 = fn() {
    var x = []
    var f = fn() {
        if (true) {
            defer x = x :+ 1
            x = x :+ 2
        }
        x = x :+ 3
        defer x = x :+ 4
    }
    f()
    assertEqual(x, [2,1,3,4], "Test 10 - inner scope LIFO then outer")
}

# 11. nested defer error/success dispatch
@test
var test11 = fn() {
    var x = []
    var f = fn(err) {
        if (true) {
            defer onerror(err) {x = x :+ "innerE"; throw err}
            defer onsuccess     x = x :+ "innerS"
            if(err) { throw "err" }
        }
        defer onerror(err) {x = x :+ "outerE"; throw err}
        defer onsuccess     x = x :+ "outerS"
    }
    f(false)
    assertEqual(x, ["innerS","outerS"], "Test 11a - nested onsuccess path")

    x = []
    var r = runSafe(fn() { f(true) })
    assertEqual(x, ["innerE"], "Test 11b - nested onerror path")
}

# 14. throw is early return and triggers defers (onerror)
@test
var test14 = fn() {
    var x = []
    var f = fn() {
        defer onerror(e) { x = x :+ "E" }
        defer x = x :+ "A"
        throw "boom"
    }
    var r = runSafe(f)
    assertEqual(x, ["A","E"], "Test 14 - throw triggers always then onerror")
}

# 15. throw ignores normal return logic (onsuccess skipped)
@test
var test15 = fn() {
    var x = []
    var f = fn() {
        defer onsuccess { x = x :+ "S" }
        throw "err"
    }
    var r = runSafe(fn() { f() })
    assertEqual(r.error, "err", "Test 15 - throw bypasses onsuccess")
}

# 16. TCO: self-tail recursion with defers that must run each iteration
# This test asserts that defers in self-tail recursion run and do not leak memory.
@test
var test16 = fn() {
    var x = []
    var loop = fn(n) {
        defer x = x :+ n
        if (n == 0) { return 0 }
        recur(n - 1)
    }
    loop(3)
    assertEqual(x, [3,2,1,0], "Test 16 - self-tail recursion defers terminate each iteration")
}

# 17. global scope defers run at program end (if harness supports it)
@test
var test17 = fn() {
    # We'll emulate program end by registering defers at top level and calling a helper
    var x = []
    defer assertEqual(x, ["start","end"], "Test 17 - global defer simulated at program end")
    defer x = x :+ "end"   # top-level defer (simulated)
    x = x :+ "start"
    # Not all harnesses auto-run global defers; we'll manually trigger them here:
    # (assumes your runtime exposes a way to flush global defers; if not, comment this)
    # For test purposes assert the current state then append "end" to emulate end-of-program.
    // x = x :+ "end"  # emulate program end
}

# 18. defer inside if/else runs only if block entered
@test
var test18 = fn() {
    var x = []
    var f = fn(cond) {
        if(cond) {
            defer x = x :+ 1
        }
    }
    f(true)
    f(false)
    assertEqual(x, [1], "Test 18 - defer only when block entered")
}

# 19. defer inside tail-call loop (recur) unrolled - each iteration defers run
@test
var test19 = fn() {
    var x = []
    var loop = fn(n, acc) {
        if (n == 0) {
            return acc
        }
        defer x = x :+ n
        recur(n-1, acc)
    }
    loop(3, [])
    assertEqual(x, [3,2,1], "Test 19 - defer in tail loop unrolled")
}

# 20. defers registering defers during unwind
@test
var test20 = fn() {
    var x = []
    var f = fn() {
        defer {
            # during unwind a defer registers another defer which should run immediately in the unwind sequence
            defer x = x :+ "inner"
            x = x :+ "outer"
        }
    }
    f()
    assertEqual(x, ["outer","inner"], "Test 20 - defers registering new defers during unwind")
}



